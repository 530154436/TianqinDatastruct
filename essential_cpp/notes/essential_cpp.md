[TOC]
#### 1. 关键字
1. **using namespace std;**
`std`: 是标准库(string class、iostream::cin/cout)命名空间的名称。
`namespace`: 一种将库名称封装起来的方法。
`using` directive: 让命名空间中的名称曝光的方法。
`char`: 表示(character)类型，如'a'、'\n'、'\t'、'\0'、'\\'、'\''、'\"'。
`const`: 常量，获得初值之后，无法再有任何变动。
`&`: 取址运算符，如 int value=1024; int* pi = &value(value的内存地址)
`*`: 取位于指针所指内存地址上的对象: \*pi==1024(读value值); \*pi=2048(写值至value，`value值改变`)

+ `main()`: 并非是程序语言定义的关键字。

#### 2. 易混淆概念
1. **指针的双重性质**
null指针: 一个未指向任何对象的指针，其地址值为0。int *p=0。
既可以让我们操作指针包含的内存地址，也可以让我们操作所指的对象值。(int \*p=&val;)
p;   => 计算p所持有的内存地址，即val的内存地址
\*p; => 求val的值

注: 使用指针之前需要检查指针是否非空。`.`为dot成员选择运算符，如果用指针，则需要改成arrow成员选择运算符`->``

2. **char\*、char ch[]和string区别**
> https://haoqchen.site/2018/09/09/string-and-char/
https://www.cnblogs.com/zhuluqing/p/8761640.html

    + 字符串指针 char* ch="hello";
    "hello"是字符串常量，不可改变，即通过ch[0]="s"会编译出错。
    ch保存“hello"这个字符串常量的首地址。

    + 字符数组 char ch[]="hello";
    字符串以字符数组的形式保存,以”\0”结尾,数组内元素可以改变。

    + 字符串 string ch
    string 由C++提供的字符串类,封装了字符串操作,比C语言的char*操作起来更安全;

3. **array和vector的异同**
(1) vector 和 array 相同，都是以一块连续内存存储其所有元素。
(1) array的大小必须固定，vector可以动态的随着元素的插入而扩展空间(内存动态分配)。
(2) array并不存储自身大小。

4. **函数指针、指针数组、数组指针**
指针数组：数组的所有元素都是指针类型，在32位系统中，指针占四个字节。
数组指针：指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。
函数指针：函数指针是指向函数的指针变量，即本质是一个指针变量。
```c++
int *a[4]         // 指针数组 <= a左边是[]，右边是*，[]优先级高，则a是数组；数组元素类型是int*，即指向整型的指针。
int (*a)[4];      // 数组指针 <= a左边是*, 则a是指针；右侧是[]，表示a指向的是数组，且数组的类型为整型。
int (*a)(int)     // 函数指针 <= a左边有个*，则a是指针；右侧是形参列表，表示a指向的是函数；再观察左侧，发现函数的返回类型是整型。
int (*a[])(int);  // 函数指针数组
```
+ [`注`]
(1) 从声明的`变量名称`开始观察
(2) `优先级`: () > [] > \*

#### 3. **局部静态对象**
在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
(1) 内存中的位置：`静态存储区`
(2) 初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
(3) 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
[`注`] 和局部非静态对象不同的是，局部静态对象所处的内存空间，即使在不同的函数函数调用过程中，依然存在。elems的内存不再像以前一样地在fibon_seq()每次调用找那时就被破坏又被重新建立。
```c++
const vector<int>* example_02_03(int size){
    static vector<int> elems;
    const int max_size = 1024;
    cout<<"size: "<<size<<endl;

    if(size<=0 || size>max_size){
        cout<<"Oops: requested size is not supported: "
            <<size<<" -- can't fulfill request.\n";
        return 0; // 即空指针
    }
    // 如果size<=elems.size()则不必重新计算
    for(long i=elems.size(); i<size; ++i){
        if(i==0 || i==1){
            elems.push_back(1);
        }else{
            elems.push_back(elems[i-1]+elems[i-2]);
        }
        cout<<elems[i]<<" ";
    }
    cout<<endl;
    return &elems;
}
int main(){
    const vector<int> *elems = example_02_03(3);
    elems = example_02_03(5);
    elems = example_02_03(7);
    display(elems);
    return 9;
}
```

#### 4. 头文件
> C/C++程序主要分为两类文件，一种是用于保存程序的声明，称为`头文件`（.h)，另一种用来保存程序的实现，称为`源文件`（.c/.cpp)。

1. 头文件（.h文件）中顺序（结构）一般如下：
（1）头文件注解（包括文件说明、功能描述、版权声明等）   （必须有）
（2）内部包含卫哨开始（#ifndef XXX/#define XXX) (必须有）
（3）#include其他头文件（如果需要）
（4）外部变量和全局函数声明（如果需要）
（5）常量和宏定义（如果需要）
（6）类型前置声明和定义（如果需要）
（7）全局函数原型和内联函数的定义（如果需要）
（8）内部包含卫哨结束：#endif   // XXX（必须有）
（9）文件版本及修订说明

2.源文件（.c/.cpp文件）其结构一般如下：
（1）源文件注解（包含文件说明、功能描述、版权声明等）（必须有）
（2）预处理指令（如果需要）
（3）常量和宏定义（如果需要）
（4）外部变量声明和全局变量定义及初始化（如果需要）
（5）成员函数和全局函数的定义（如果需要）
（6）文件按修改记录

2. 关键字
 (1) extern 声明函数
 (2) #ifendif 卫哨，防止多次包含一个文件

3. ""与<>的区别
 (1) 如果此头文件被认为是`标准的`、或项目专属的头文件，我们便以<>将文件名括住，编译器搜索此文件时会在`默认的目录`中寻找，如#include<xxx.h> 。
 (2) 如果头文件是`用户`自己定义的，我们便以""将文件名括住，编译器搜索此文件时会从`当前工程所在目录`开始寻找，然后在从标准头文件目录中查找。如#include "xxx.h"。

4. 小结
 (1) 函数的定义只能有一份，但可以有许多份声明。
 (2) `inline`、'template'函数的定义要写在头文件中。
 (3) `const`对象（变量）一出文件外便不可见。这意味着我们可以在多个程序代码中加以定义，不会导致任何错误。

#### 5. 出现的问题
1. **ld: 1 duplicate symbol for architecture x86_64**
出现错误的原因是：重复定义。

#### 6. 参考
[1] C++参考手册 https://zh.cppreference.com/