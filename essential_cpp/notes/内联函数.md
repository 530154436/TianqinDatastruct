[TOC]
#### 1. 内联函数的作用
1. inline 和 宏定义#define的作用基本类似，都是替换或者展开。
2. 在程序编译阶段，如果遇到内联函数，则将内联函数的实现在当前位置展开。
3. 内联的`目的`是为了减少函数的调用开销，从而提高运行效率，但会增加代码体量。
+ [注]
内联只是一种建议，并不要求编译器必须执行。如果内联函数本身开销较大（含有for,switch,递归等），编译器可能拒绝内联展开。

#### 2. 内联函数的实现
+ 内联函数的实现比较简单，即在 函数定义体 前加上`inline`关键字。
+ [注] 仅在函数声明前加上 “inline”是不起作用的，`必须加在函数定义体前`。
```c++
inline bool is_size_ok(int size, const int max_size){
    if(size<0 || size>max_size){
        cout<<"Oops: requested size is not supported: "
            <<size<<" -- can't fulfill request.\n";
        return false;
    }
    return true;
}
inline const vector<int>* fibon_seq(int size){
    const int max_size = 1024;
    static vector<int> elems;
    cout<<"size: "<<size<<endl;
    if(!is_size_ok(size, max_size)) return 0;

    // 如果size<=elems.size()则不必重新计算
    for(long i=elems.size(); i<size; ++i){
        if(i==0 || i==1){
            elems.push_back(1);
        }else{
            elems.push_back(elems[i-1]+elems[i-2]);
        }
        cout<<elems[i]<<" ";
    }
    cout<<endl;
    return &elems;
}
bool example_02_04(int pos, int& elems){
    // p55
    const vector<int>* pseq = fibon_seq(pos);
    if(!pseq){
        elems =0;
        return false;
    }
    elems = (*pseq)[pos-1];
    return true;
}

int main(){
    int elem = 0;
    example_02_04(5, elem);
    cout<<"pos:"<<5<<", elem:"<<elem<<endl;
    example_02_04(7, elem);
    cout<<"pos:"<<7<<", elem:"<<elem<<endl;

    return 0;
}

```

#### 3. 内联函数的优缺点、使用场景
1. 优点
（1）通过避免函数的回调，加速了程序的执行；
（2）通过利用指令缓存，`增强局部访问性`；
（3）使用内联可以替换重复的短代码，方便代码管理；

2. 缺点
（1） 由于是替换展开，因此会增大代码体量；
（2）一旦修改内联，所有用到该内联的地方都需要重新编译；

3. 内联函数的使用场景
（1）需要提高程序运行效率；
（2）需要用内联替代宏定义来实现某些功能；
（3）在类中声明同时定义的成员函数，自动转化为内联函数，如果需要隐藏该函数的实现细节，则在类外定义内联；